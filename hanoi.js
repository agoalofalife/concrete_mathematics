

// Свои размышление на эту тему если лень читать то можно спуститься ниже там просто код

// Основный термины из этой задачи которые можно вынести и они черт возьми не зазубривуются как из книги
// * Реккуретность ( для меня понятнее это называть рекурсивной зависимостью )
//     Реккуретность- последовательности, каждый следующий член которых, начиная с нек-рого,
//     выражается по определенному правилу через предыдущие;

// * Математическая индукция используется, чтобы доказать истинность некоего утверждения для всех натуральных чисел.


//  По самой задачи условие которой нам известно наизусть

// 1.Tn это минимальное кол-во перекладываний, где n это кол-во дисков а T это минимално кол-во операций
// сама работы Т нам пока не известно , но как говориться ведуться работы подождите приходите завтра.

// 2. Как переместить до 2 дисков нам вполне очевидно, но ключевой момент к пониманию алгоритма кроется с
// 3 диска .
// Если можно так назвать( а мне можна я ведь не великий математик ) то все строиться на 3 комбинациях
// первая из них это перемещения дисков на промежуточный стоб, перемещение большого диска на столб который
// предназначался с самого начала и перемещение дисков с промажуточного на конечный.

// Математически можно это выразить так ( 2Тn-1 + 1 ) где помним что T  это у нас кол-во операций
// а n-1 потому что большой диск не задействован, + 1 как раз перемещение нашего самого крупного диска

// Далее нам необходимо найти то самое T
// Из книги методом угадывания (как написано) выходит что Т равно Tn = 2 в степени n -1
// заканомерность такова что кол-во ровнется кол-во операция для комбинация один и три описанных мною раннее,
// соответственно достаточно умножить это на два и прибавить 1 (Эээ 1 !?, Да диск самыыый большой)

// Соответсвенно общие выражения
// Tn = 2Tn-1 + 1 = 2(2 в степени n-1 - 1) + 1 = 2 в степени n -1
// первая часть это с нами выражение которое было в самом начале
// второя часть это выражение которое было нами доказано то есть T
// а третье это просто сокращение всего

// Выражая математически все довольно таки легко если прочитать не один раз
// Решение задачи кодом сложнее но он как то пока ближе



// КОД-----------------------------

//  функция просто кладет из A в B
// condition это у нас будет параметр с состоянием трех столбов
// ведь функция не о каком массиве не знает да и не должна вроде как

function move( one_pin, two_pin , condition ) {
    condition[two_pin].unshift( condition[one_pin].shift() ) ;
}

// функция для нахождения промежуточного стоба
function get_intermediate_pin( one_pin, two_pin ) {
    let template_pin = [0,1,2];

    return +template_pin.filter(function ( item ) {
        return item !== one_pin && item !== two_pin ;
    });
}

// N кол-во дисков
// Первый столбец на котором находятся диски
// Второй стобец для перемещения
function solve_hanoi (N, one_pin, two_pin, condition) {
    if (N === 1) {
        move(one_pin, two_pin, condition);
    }
    // для всех N > 1
    else {
        let intermediate_rod = get_intermediate_pin(one_pin, two_pin);

        solve_hanoi(N - 1, one_pin, intermediate_rod, condition);

        move(one_pin, two_pin, condition);

        solve_hanoi(N - 1, intermediate_rod, two_pin, condition);
    }
}

// простой тест
let source = [[1,2,3,4,5],[],[]];
solve_hanoi(5,0,2, source);
console.log( source );


// можно конечно написать тестов но задача совсем другом