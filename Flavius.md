## Задача Иосифа Флавия

---



> Задача основана на легенде, что отряд Иосифа Флавия, защищавший город Йодфат, не пожелал сдаваться в плен блокировавшим пещеру превосходящими силам римлян. Воины, в составе сорока человек, стали по кругу и договорились, что каждые два воина будут убивать третьего, пока не погибнут все. При этом двое воинов, оставшихся последними в живых, должны были убить друг друга. Иосиф Флавий, командовавший этим отрядом, якобы быстро рассчитал, где нужно встать ему и его товарищу, чтобы остаться последними, но не для того, чтобы убить друг друга, а чтобы сдать крепость римлянам

Начертим круг и расставим вдоль него цифры ~~люди~~

![Круг](http://i12.pixs.ru/storage/9/7/4/1486014025_8884417_25019974.png)

После первого прохода по кругу мы можем заметить что у нас остаются следующие числа

![Круг](http://i12.pixs.ru/storage/9/9/3/circleones_9347590_25019993.png)

```
1 3 5 7 9
```
После второго круга 

![Круг](http://i12.pixs.ru/storage/0/0/5/circleonet_9684156_25020005.png)

```
5 9
```

В итоге у нас останется цифра 5

В итоге при J(10) = 5

> Вполне можно предположить что J(n) = n/2 (если n четно) в этом мы убеждаемя при n = 2, однако если рассмотреть другие случае это "гипотеза" отпадает

Теперь представим круг с 2n 
> Прошу прощения за неровные картинки , перфекционисты терпите

![Круг](http://i12.pixs.ru/storage/0/5/6/20jpg_4151589_25020056.jpg)

Пройдем первый круг и увидим

![Круг](http://i12.pixs.ru/storage/0/6/3/20steponej_4997890_25020063.jpg)

```
1 3 5 7 9 11 13 15 17 19

//Можно записать так

 2n - 1 = 20 - 1  = 19
 2n - 3 = 20 - 3  = 17
 2n - 5 = 20 - 5  = 15 
...
```
Давайте вычеркнем все последующие шаги и изобразим их тут

** Шаг 2 **

![Круг](http://i12.pixs.ru/storage/1/1/9/20steptwoj_5540273_25020119.jpg)


** Шаг 3**

![Круг](http://i12.pixs.ru/storage/1/2/6/20stepthre_8123906_25020126.jpg)

** Шаг 4 Последний**

![Круг](http://i12.pixs.ru/storage/1/3/0/20stepfour_4738959_25020130.jpg)

В итоге у нас осталась **9**

```
J(10) = 5
J(20) = 9
// Напрашивается вывод что при n >= 0  номер каждого уцелевшего удваивается и уменьшается на 1
// Записать это можно что то вроде того
J(2n) = 2J(n) - 1
```

Теперь рассмотрим нечетный случай

Если у нас 2n + 1 например 21

После первого прохода, цифра 1 зачеркивается сразу перед 2n

Только цифры уцелевших удваиваются и увеличиваются на 1

Изобразить это можно так  **J(2n + 1 ) = 2J(n) + 1** при n >= 1

```
J(1) = 1

J(2n)     = 2J(n) -1 ,  n > = 1

J(2n + 1) = 2J(n) + 1 , n >= 1

```


Я решил составить таблицу 

| n    | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 |
|------|---|---|---|---|---|---|---|---|---|----|----|----|---:|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
| J(n) | 1 | 1 | 3 | 1 | 3 | 5 | 7 | 1 | 3 | 5  | 7  | 9  | 11 | 13 | 15 | 1  | 3  | 5  | 7  | 9  | 11 | 13 | 15 | 17 | 19 | 21 | 23 | 25 | 27 | 29 | 31 | 1  |


Обратите внимание на таблицу снизу я обвел числа

![table](http://i9.pixs.ru/storage/4/2/8/tablenumbe_5979888_25020428.png)

Закономерность такова что числа снизу начинаются с **1** а числа с верху не как иначе называются
степень двойки


2<sup>2</sup> = 4

2<sup>3</sup> = 8

2<sup>4</sup> = 16

2<sup>5</sup> = 32


Мы можем это выразить 

n = 2<sup>m</sup> + k

То есть например у нас число 22

2<sup>m</sup>  = 16

k = 6

В итоге **2<sup>4</sup> + 6 = 16 + 6 = 22**


В рекуррентном соотношение выглядит так : 

** J(2<sup>m</sup> + k) = 2k + 1** при **m >= 0 и 0 <= k < 2<sup>m</sup>**

 Если в краткости

* Мы зачеркиваем ровно **k** чисел и у нас остается 2<sup>m</sup>
* Оставшиеся число это ** 2k + 1 **


Для того чтобы доказать мы будем использовать  индукцию по  m 

При m = 0 мы имеем k = 0

J(2<sup>m</sup>  + k) = 2J(2<sup>m-1</sup> + k/2) - 1 = 2(2k/2 +1) -1 = 2k + 1

2k + 1 это и есть наш ответ


---


Отлично давай те решим нашу задачу в двоичной сис ме 

**n = b<sub>m</sub>2<sup>m</sup> + b<sub>m-1</sub>2<sup>m-1</sup> + ... b<sub>1</sub>2 + b<sub>0</sub>**

Тут представлена n  в двоичной сис - ме

Например возьмем **22<sub>10</sub> = 10110<sub>2<sub> **

По формуле сверху это выглядит так : 

**  n  = 1<sub>4</sub>2</sub><sup>4</sup> + 0<sub>4-1</sub>2</sub><sup>4-1</sup> + 1<sub>4-2</sub>2</sub><sup>4-2</sup> + 1<sub>4-3</sub>2</sub><sup>4-3</sup> +
0<sub>4 - 4 </sub>2</sub><sup>4 - 4</sup>  = 22<sub>10</sub>**

Теперь разложим наши рассуждения выше для двоичной сис мы

![2](http://i12.pixs.ru/storage/7/7/3/dvoichnaya_5550421_25028773.jpg)

В двоичной сис - ме легче заметить закономерность.

Для того чтобы получить нужный нам ответ , мы должны первую цифру n поставить в конец, тем самым сдвинуть все цифры и  если спереди возникнут нули их отбросить

22<sub>10</sub> = 10110<sub>2</sub>

Ответ  : 1101<sub>2</sub> = 13<sub>10</sub> 

---



Давайте на данный момент отвлечемся от метематических рассуждений и попробуем решить нашу задачу с помощью кода.


Давай те накидаем наш план :

* Написать функцию по генерации массива , на вход принимает один параметр с кол - ом бойцов , возвращает нам массив с "бойцами" в виде цифр

* Написать вторую функцию ( основную )  , принимает на вход шаг , то есть через какой промежуток мы зачеркиваем война , сам массив

* Основная функция должна проходить по всему массиву и возвращать число оставшийся война


```javascript
// Возвращает массив с указанным кол ом элементов

function range(N) {
    let box = [];
    for (let i = 1; i <= N; i++) box.push(i);
    return box;
}
```

Отлично теперь начнем писать основную функцию.
```javascript
// Назовем ее последний герой , остаться в живых

function get_last_hero(box_fighters, step){
 
  // Если у нас остался один воин мы возвращаем его номер
   if(box_fighters.length == 1){
     return box_fighters.shift();
   } 
   // Если шаг превысил количество элементов в массиве
   // то мы должны его переопределить для нового круга
   if(step  > box_fighters.length){
   
    step = step % box_fighters.length;
    }
  
    // "убиваем война" след по счету путем извлечения и сокращения массива на 1
    box_fighters.splice(step - 1,1);
    
    // след шаг
    return get_last_hero(box_fighters,step + 1);
}

// еще надо добавить что при N = 0 то return 0
```
Теперь все прекрасно работает можно проверить

```
let random_army = range(10);

get_last_hero(random, 2);
//5

```

---



```
Так же в текущей директории вы можете демонстрационно посмотреть в действие эту задачу

```

![задача в действие](http://g.recordit.co/3iUBOqCrRe.gif)