## ЗАДАЧА О РАЗРЕЗАНИИ ПИЦЦЫ
```text    
Сколько кусков пиццы можно получить, делая N прямолинейных разрезов ножом?
```

Давай те начнем размышлять с самых очевидных случаев.

Если   **L<sub>0</sub>**  это плоскость без прямых - это одна область это вполне логично.


При    **L<sub>1</sub>** с одной  прямой это две области.
![Две области](http://i12.pixs.ru/storage/9/1/4/oblast2jpg_9017709_24997914.jpg)


При L2 четыре области
![Четыре области](http://i12.pixs.ru/storage/9/5/0/2imagejpg_8666988_24997950.jpg)

Из этих рисунков напрашивается вывод что **L<sub>n</sub> = 2<sup>n</sup>** 

Это неверно!! Удвоение происходит если прямая рассекает каждую область, тем самым делить ее на 2

Давайте добавим еще прямую

![Семь областей](http://i12.pixs.ru/storage/1/0/1/3imagejpg_6236578_24998101.jpg)

Как видно из рисунка у максимум добавляется 3 новых областей 
то есть **L<sub> 3</sub> = 7** 
 
Давай те составим обобщение :

 ```text    
Новая прямая если она больше 0, увеличивает число областей на k только тогда, когда рассекает k старых областей
это логично ведь прямая делит на два старые области.
А пересекает она прямые  k - 1 различных точкаx (То есть две прямые пересекаются в одной точке) а последующие
 n -1 прямых не более чем в n -1 различных точках.
При этом k меньше или равно n
```

Давай те напишем с вами что мы тут подытожили

 ```text    
L(n)  <=  L(n-1) + n при  n > 0
```
 На самом деле теперь задачу можно решить с помощью кода, давай те его набросаем


 ```javascript     
  // Функция получить количество областей
 // На вход она принимает кол-во прямых

 function get_number_areas(N) {

 //Если прямых нет то область одна

if  (N == 0) {
  return 1;
  }
//Если прямая одна то области 2 L(1) = 2
  if(N == 1){

  return 2;

  } else {
 // иначе областей больше мы делаем то до чего с вами догадались ранее

 return  get_number_areas(N-1) + N;
 }
  
 }
```
Проведем тесты все работает
```test

get_number_areas(1);
// 2
get_number_areas(2);
// 4
get_number_areas(3);
// 7
get_number_areas(4);
// 11
get_number_areas(5);
// 16
```
Можно улучшить функцию 

```javascript

function get_number_areas(N) {
if  (N === 0) {
  return 1;
  } else {
 return get_number_areas(N-1) + N;
 }
  
 }

```

---


 Теперь продолжим математические рассуждения
 Нам необходимо разобраться в рекуррентности, в книги предлагается ее развернуть 

![Семь областей](http://dl3.joxi.net/drive/2017/02/01/0017/1804/1177356/56/6890c125fb.jpg)

Разворачивая ее таким образом мы получаем сумму всех чисел + 1

```
// Например при L(1) , L(2) , L(3), L(4)

L(1) = L(1-1) + 1 = L(0) + 1 = 1

L(2) = L(2-2) + (2-1)  + 2 = L(0) + 1 + 2 = 3

L(3) = L(3-3) + (3-2) + (3-1) + 3 = L(0) + 1 + 2 + 3 = 6

L(4) = L(4-4) + (4-3) + (4-2) + (4-1) + 4 + L(0) +1 + 2 + 3 + 4 = 10

```
То есть ** L(n) = Sn + 1 **

Еще Sn называет **треугольными числами** где каждый уровень увеличивается на 1

```
// Например S(4) = 10
   1            1
  2 3           2 3
 4 5 6          4 5 6
7 8 9 10        7 8 9 10
```
Нам необходимо извлечь формулу чтобы каждый раз не разворачивать всю конструкцию

Для этого воспользуемся уловкой Гаусса
 
Выглядит это примерно так


![Уловка Гаусса](http://i12.pixs.ru/storage/4/0/5/ScreenShot_4502233_25003405.png)

Если просто то мы записываем Sn два раза один под другим только вторую наоборот

```
// Для S(4) это будет выглядеть примерно так

(n-3) + (n -2)  + (n-1)   + n
   n  + (n - 1) + (n - 2) + (n -3)

// то есть 
             (1) + (2) + (3) + 4
              4  + (3) + (2) + (1)
-----------------------------------------------
2S(n) = ( n + 1 )+( n + 1 )+( n + 1 )+( n + 1 )

```
То есть ** 2Sn = n * (n + 1) ** или **S(n) = n(n + 1) / 2 **

Следовательно мы нашли S(n) и для L(n) получается

**L(n) = ( n * (n + 1) / 2) + 1;**